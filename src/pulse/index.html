<html>
<head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
    <div id="cpu_temperature"></div>
    <div id="outside_temperature"></div>
    <div id="humidity"></div>
    <div id="pressure"></div>
    <div id="flow"></div>
    <div id="level"></div>

    <script>
        function extendChart(div, x, y) {
            Plotly.extendTraces(div, {
                x: [[x]],
                y: [[y]]
            }, [0], 60);
        }

        function createChart(div, title, time_series, data_series) {
            //timestamp = data.time;
            //timestamp -= 59*1000;
            //x = Array(60)
            //y = Array(60)
            //for(var i=0 ; i<60; i++) {
            //    x[i] = new Date(timestamp+i*1000);
            //    y[i] = null;
            //}
            x = Array(time_series.length)
            y = Array(time_series.length)
            for(var i=0 ; i<time_series.length; i++) {
                x[i] = new Date(time_series[i]);
                y[i] = data_series[i];
            }
            var data = [{
                x: x,
                y: y,
                mode: 'lines',
                line: {color: '#80CAF6'}
            }];

            var layout = {
                title: title,
                //yaxis: { range: [0, 100] },
                //xaxis: { tickmode: 'linear', tick0: new Date(timestamp), dtick: 10*1000 }
                //xaxis: { tickmode: 'linear' }
            };

            Plotly.plot(div, data, layout);            
        }

        function createCharts(data) {
            if(data.cpu_temperature != null) {
                createChart('cpu_temperature', 'CPU temperature', data.time, data.cpu_temperature);
                createChart('outside_temperature', 'Outside temperature', data.time, data.outside_temperature);
                createChart('humidity', 'Humidity', data.time, data.humidity);
                createChart('pressure', 'Pressure', data.time, data.pressure);
                createChart('flow', 'Flow', data.time, data.flow);
                createChart('level', 'Level', data.time, data.level);

                console.log('Created chart with '+data.time.length+' points');
                chartsCreated = true;
            }
        }

        var chartsCreated = false;

        function nextDataReceived(requestId, data) {
            console.log('Processing request '+requestId+', data '+data);

            if(!chartsCreated) {
                createCharts(data)
            }

            if(chartsCreated) {
                extendChart('cpu_temperature', data.time, data.cpu_temperature);
                extendChart('outside_temperature', data.time, data.outside_temperature);
                extendChart('humidity', data.time, data.humidity);
                extendChart('pressure', data.time, data.pressure);
                extendChart('flow', data.time, data.flow);
                extendChart('level', data.time, data.level);
            }
        }

        var lastProcessedRequestId = 0;
        var receivedUnorderedStats = {};

        function dataReceived(requestId, data) {
            // if packets do not come in order, this will not work
            // console.log('data received '+data.toSource()+', request '+requestId);
            nextDataReceived(requestId, data);
            return;

            // receivedUnorderedStats[requestId] = data;

            // while(requestId == lastProcessedRequestId+1) {
            //     data = receivedUnorderedStats[requestId];
            //     nextDataReceived(requestId, data);
            //     delete receivedUnorderedStats[requestId];

            //     lastProcessedRequestId++;
            //     if(requestId+1 in receivedUnorderedStats) {
            //         requestId++;
            //     }
            // }
        }

        function emptyData(time) {
            return {time: time, cpu_temperature: null, outside_temperature: null, pressure: null, humidity: null, flow: null, level: null};
        }

        function parseData(time, response) {
            var data = JSON.parse(response);
            //data.time = time;
            return data;
        }

        var sentRequestId = 0;

        function sendHttpGetCurrent() {
            var xmlHttp = new XMLHttpRequest();
            xmlHttp.open("GET", window.location.href+'current');
            xmlHttp.onload = function(e) {           
                console.log("Response to request "+this.requestId+" received at "+new Date()+", status="+this.status);

                var data;
                if(this.status == 200) {
                    data = parseData(this.requestDate, this.response);
                }
                else {
                    data = emptyData(this.requestDate);
                }
                dataReceived(this.requestId, data);
            }
            xmlHttp.onerror = function(e) {
                console.log("ERROR for request "+this.requestId+" received at "+new Date());
                data = emptyData(this.requestDate);
                dataReceived(this.requestId, data);
            }
            xmlHttp.requestId = ++sentRequestId;
            xmlHttp.requestDate = new Date();
            xmlHttp.send(null);
            console.log("HTTP GET request "+sentRequestId+" sent at "+new Date());
        }

        function sendHttpGetHistorical() {
            var xmlHttp = new XMLHttpRequest();
            xmlHttp.open("POST", window.location.href+'query');
            xmlHttp.setRequestHeader("Content-Type", "application/json");

            var queryPeriod = new Date();
            queryPeriod.setMinutes(queryPeriod.getMinutes()-1);
            var data = JSON.stringify({"from": queryPeriod.toISOString()});

            xmlHttp.requestDate = new Date();
            xmlHttp.send(data);
            console.log("HTTP GET historical request sent at "+new Date());

            xmlHttp.onload = function(e) {
                console.log("Response to historical request received at "+new Date()+", status="+this.status);

                if(this.status == 200) {
                    data = parseData(this.requestDate, this.response);
                }
                if(!chartsCreated) {
                    createCharts(data);
                }

                startPeriodicPulling();
            }
            xmlHttp.onerror = function(e) {
                console.log("ERROR for historical request received at "+new Date());

            }
        }

        function startPeriodicPulling() {
            var interval = setInterval(function() {
                sendHttpGetCurrent();
            }, 1000);
        }

        sendHttpGetHistorical()
    </script>
</body>
</html>