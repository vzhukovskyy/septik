<html>
<head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
    <div id="cpu_temperature"></div>
    <div id="outside_temperature"></div>
    <div id="humidity"></div>
    <div id="pressure"></div>
    <div id="flow"></div>
    <div id="level"></div>

    <script>
        function calculateRange(array) {
            min = Math.floor(Math.min(...array));
            max = Math.ceil(Math.max(...array))

            if(min == max) {
                max = min+1;
            }
            if(min+1 == max) {
                var sum = 0;
                for(var i=0; i<array.length; i++)
                    sum = sum+array[i];
                var avg = sum/array.length;

                if(max-avg > avg-min)
                    min = min-1;
                else
                    max = max+1;
            }

            return [min,max];
        }

        function extendChart(div, x, y) {
            Plotly.extendTraces(div, {
                x: [[x]],
                y: [[y]]
            }, [0], 60);

            range = calculateRange(document.getElementById(div).data[0].y);

            Plotly.relayout(div, 'yaxis.range', range);
        }

        function createChart(div, title, time_series, data_series) {
            if(!time_series) {
                x = []
                y = []
            }
            else {
                x = Array(time_series.length)
                y = Array(time_series.length)
                for(var i=0 ; i<time_series.length; i++) {
                    x[i] = new Date(time_series[i]);
                    y[i] = data_series[i];
                }
            }

            range = calculateRange(y);

            var data = [{
                x: x,
                y: y,
                mode: 'lines',
                line: {color: '#80CAF6'}
            }];

            var layout = {
                title: title,
                yaxis: {
                    autotick: false,
                    dtick: 1,
                    range: range
                }
            };

            Plotly.plot(div, data, layout, {staticPlot: true});
        }

        function createCharts(data) {
            createChart('cpu_temperature', 'CPU temperature', data.time, data.cpu_temperature);
            createChart('outside_temperature', 'Outside temperature', data.time, data.outside_temperature);
            createChart('humidity', 'Humidity', data.time, data.humidity);
            createChart('pressure', 'Pressure', data.time, data.pressure);
            createChart('flow', 'Flow', data.time, data.flow);
            createChart('level', 'Level', data.time, data.level);

            console.log('Created chart with '+(data.time ? data.time.length : 0)+' points');
            chartsCreated = true;
        }

        var chartsCreated = false;

        function nextDataReceived(requestId, data) {
            console.log('Processing request '+requestId+', data '+data.time);

            if(chartsCreated) {
                extendChart('cpu_temperature', data.time, data.cpu_temperature);
                extendChart('outside_temperature', data.time, data.outside_temperature);
                extendChart('humidity', data.time, data.humidity);
                extendChart('pressure', data.time, data.pressure);
                extendChart('flow', data.time, data.flow);
                extendChart('level', data.time, data.level);
            }
        }

        var lastProcessedRequestId = 0;
        var receivedUnorderedStats = {};

        function dataReceived(requestId, data) {
            // re-order packets
            
            receivedUnorderedStats[requestId] = data;

            while(requestId == lastProcessedRequestId+1) {
                data = receivedUnorderedStats[requestId];
                nextDataReceived(requestId, data);
                delete receivedUnorderedStats[requestId];

                lastProcessedRequestId++;
                if(requestId+1 in receivedUnorderedStats) {
                    requestId++;
                }
            }
        }

        function emptyData(time) {
            return {time: time, cpu_temperature: null, outside_temperature: null, pressure: null, humidity: null, flow: null, level: null};
        }

        function parseData(time, response) {
            var data = JSON.parse(response);
            return data;
        }

        var sentRequestId = 0;

        function sendHttpGetCurrent() {
            var xmlHttp = new XMLHttpRequest();
            xmlHttp.open("GET", window.location.href+'current');
            xmlHttp.onload = function(e) {           
                //console.log("Response to request "+this.requestId+" received at "+new Date()+", status="+this.status);

                var data;
                if(this.status == 200) {
                    data = parseData(this.requestDate, this.response);
                }
                else {
                    data = emptyData(this.requestDate);
                }
                dataReceived(this.requestId, data);
            }
            xmlHttp.onerror = function(e) {
                console.log("ERROR for request "+this.requestId+" received at "+new Date());
                data = emptyData(this.requestDate);
                dataReceived(this.requestId, data);
            }
            xmlHttp.requestId = ++sentRequestId;
            xmlHttp.requestDate = new Date();
            xmlHttp.send(null);
            //console.log("HTTP GET request "+sentRequestId+" sent at "+new Date());
        }

        function sendHttpGetHistorical() {
            var xmlHttp = new XMLHttpRequest();
            xmlHttp.open("POST", window.location.href+'query');
            xmlHttp.setRequestHeader("Content-Type", "application/json");

            var queryPeriod = new Date();
            queryPeriod.setMinutes(queryPeriod.getMinutes()-1);
            var data = JSON.stringify({"from": queryPeriod.toISOString()});

            xmlHttp.requestDate = new Date();
            xmlHttp.send(data);
            console.log("HTTP GET historical request sent at "+new Date());

            xmlHttp.onload = function(e) {
                console.log("Response to historical request received at "+new Date()+", status="+this.status);

                if(this.status == 200) {
                    data = parseData(this.requestDate, this.response);
                }
                if(!chartsCreated) {
                    createCharts(data);
                }

                startPeriodicPulling();
            }
            xmlHttp.onerror = function(e) {
                console.log("ERROR for historical request received at "+new Date());

            }
        }

        function startPeriodicPulling() {
            var interval = setInterval(function() {
                sendHttpGetCurrent();
            }, 1000);
        }

        sendHttpGetHistorical()
    </script>
</body>
</html>